unit TenLevel;

//  *************************************************
//    Generated By: JsonToDelphiClass - 0.65
//    Project link: https://github.com/PKGeorgiev/Delphi-JsonToDelphiClass
//    Generated On: 2016-06-30 15:10:43
//  *************************************************
//    Created By  : Petar Georgiev - 2014
//    WebSite     : http://pgeorgiev.com
//  *************************************************

interface

uses Generics.Collections, Rest.Json;

type

TSellPankouClass = class
private
  FPrice: Extended;
  FVolume: Extended;
public
  property price: Extended read FPrice write FPrice;
  property volume: Extended read FVolume write FVolume;
  function ToJsonString: string;
  class function FromJsonString(AJsonString: string): TSellPankouClass;
end;

TBuyPankouClass = class
private
  FPrice: Extended;
  FVolume: Extended;
public
  property price: Extended read FPrice write FPrice;
  property volume: Extended read FVolume write FVolume;
  function ToJsonString: string;
  class function FromJsonString(AJsonString: string): TBuyPankouClass;
end;

TDataClass = class
private
  FBuyPankou: TArray<TBuyPankouClass>;
  FMatch: Extended;
  FPreClose: Extended;
  FSellPankou: TArray<TSellPankouClass>;
  FType: Extended;
public
  property buyPankou: TArray<TBuyPankouClass> read FBuyPankou write FBuyPankou;
  property match: Extended read FMatch write FMatch;
  property preClose: Extended read FPreClose write FPreClose;
  property sellPankou: TArray<TSellPankouClass> read FSellPankou write FSellPankou;
  property &type: Extended read FType write FType;
  destructor Destroy; override;
  function ToJsonString: string;
  class function FromJsonString(AJsonString: string): TDataClass;
end;

TRootClass = class
private
  FCode: Extended;
  FData: TDataClass;
  FMessage: String;
  FSuccess: Boolean;
public
  property code: Extended read FCode write FCode;
  property data: TDataClass read FData write FData;
  property message: String read FMessage write FMessage;
  property success: Boolean read FSuccess write FSuccess;
  constructor Create;
  destructor Destroy; override;
  function ToJsonString: string;
  class function FromJsonString(AJsonString: string): TRootClass;
end;

implementation

{TSellPankouClass}


function TSellPankouClass.ToJsonString: string;
begin
  result := TJson.ObjectToJsonString(self);
end;

class function TSellPankouClass.FromJsonString(AJsonString: string): TSellPankouClass;
begin
  result := TJson.JsonToObject<TSellPankouClass>(AJsonString)
end;

{TBuyPankouClass}


function TBuyPankouClass.ToJsonString: string;
begin
  result := TJson.ObjectToJsonString(self);
end;

class function TBuyPankouClass.FromJsonString(AJsonString: string): TBuyPankouClass;
begin
  result := TJson.JsonToObject<TBuyPankouClass>(AJsonString)
end;

{TDataClass}

destructor TDataClass.Destroy;
var
  LbuyPankouItem: TBuyPankouClass;
  LsellPankouItem: TSellPankouClass;
begin

 for LbuyPankouItem in FBuyPankou do
   LbuyPankouItem.free;
 for LsellPankouItem in FSellPankou do
   LsellPankouItem.free;

  inherited;
end;

function TDataClass.ToJsonString: string;
begin
  result := TJson.ObjectToJsonString(self);
end;

class function TDataClass.FromJsonString(AJsonString: string): TDataClass;
begin
  result := TJson.JsonToObject<TDataClass>(AJsonString)
end;

{TRootClass}

constructor TRootClass.Create;
begin
  inherited;
  FData := TDataClass.Create();
end;

destructor TRootClass.Destroy;
begin
  FData.free;
  inherited;
end;

function TRootClass.ToJsonString: string;
begin
  result := TJson.ObjectToJsonString(self);
end;

class function TRootClass.FromJsonString(AJsonString: string): TRootClass;
begin
  result := TJson.JsonToObject<TRootClass>(AJsonString)
end;

end.

