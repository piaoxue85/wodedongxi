#上次你提到 回测结果显示中 显示最大回撤的时间段 
#m6.pyfolio_full_tear_sheet()   这个接口可以满足你的需求

# 获取股票代码
instruments = D.instruments()
# # 确定起始时间
start_date = '2017-08-01' 
# 确定结束时间
end_date = '2018-02-23' 

# # 确定起始时间
# start_date = '2007-01-01' 
# # 确定结束时间
# end_date = '2018-01-17' 

# # 确定起始时间
# start_date = '2005-01-01 ' 
# # 确定结束时间
# end_date = '2007-11-01'  

# 起始日期
# start_date = '2006-01-01'
# # 结束日期
# end_date = '2007-01-08'


# 获取股票总市值数据，返回DataFrame数据格式
def get_data(date=""):
    market_cap_data = D.history_data(instruments,date,date,fields=['market_cap','eps','amount',"st_status","pe_ttm"])
    daily_buy_stock = market_cap_data.apply(lambda df:df[(df['amount'] > 0) & (df['st_status'] == 0) ])
    return daily_buy_stock

# 回测参数设置，initialize函数只运行一次
def initialize(context):
    # 手续费设置
    context.set_commission(PerOrder(buy_cost=0.001, sell_cost=0.001, min_cost=5)) 
    # 调仓规则（每月的第一天调仓）
    context.schedule_function(rebalance, date_rule=date_rules.month_start(days_offset=0)) 
    # 传入 整理好的调仓股票数据
    context.daily_buy_stock = daily_buy_stock
    set_long_only()
#     set_max_leverage(1)  

#     print(context.daily_buy_stock)

# handle_data函数会每天运行一次
def handle_data(context,data):
    if data.current_dt.strftime('%Y-%m-%d') == end_date :
        # 打印持仓的股票
         positions = context.portfolio.positions
         for equity in positions:
             position = positions[equity]
             print(position.sid)
    

# 换仓函数
def rebalance(context, data):
    # 当前的日期
    date = data.current_dt.strftime('%Y-%m-%d')
    # 根据日期获取调仓需要买入的股票的列表
    stock_to_buy = list(context.daily_buy_stock.ix[date].instrument)

    # 通过positions对象，使用列表生成式的方法获取目前持仓的股票列表
    stock_hold_now = [equity.symbol for equity in context.portfolio.positions]
    # 继续持有的股票：调仓时，如果买入的股票已经存在于目前的持仓里，那么应继续持有
    no_need_to_sell = [i for i in stock_hold_now if i in stock_to_buy]
    # 需要卖出的股票
    stock_to_sell = [i for i in stock_hold_now if i not in no_need_to_sell]
  
    # 卖出
    for stock in stock_to_sell:
        # 如果该股票停牌，则没法成交。因此需要用can_trade方法检查下该股票的状态
        # 如果返回真值，则可以正常下单，否则会出错
        # 因为stock是字符串格式，我们用symbol方法将其转化成平台可以接受的形式：Equity格式

        if data.can_trade(context.symbol(stock)):
            # order_target_percent是平台的一个下单接口，表明下单使得该股票的权重为0，
            #   即卖出全部股票，可参考回测文档
            context.order_target_percent(context.symbol(stock), 0)
    
    # 如果当天没有买入的股票，就返回
    if len(stock_to_buy) == 0:
        return

    # 等权重买入 
    weight =  1 / len(stock_to_buy)
    
    # 买入
    for stock in stock_to_buy:
        if data.can_trade(context.symbol(stock)):
            # 下单使得某只股票的持仓权重达到weight，因为
            # weight大于0,因此是等权重买入
#             print(context.symbol(stock))
            context.order_target_percent(context.symbol(stock), weight)
#             print(stock)

m = M.trade.v2(
    instruments=instruments,
    start_date=start_date,
    end_date=end_date,
    initialize=initialize,
    handle_data=handle_data,
    # 买入订单以开盘价成交
    order_price_field_buy='open',
    # 卖出订单以开盘价成交
    order_price_field_sell='close',
    # 策略本金    
    capital_base=400000,
    # 比较基准：沪深300
    benchmark='000300.INDX',
    # 传入数据给回测模块，所有回测函数里用到的数据都要从这里传入，并通过 context.options 使用，否则可能会遇到缓存问题
    m_cached=False,
    volume_limit=0,    
#     options={'selected_data': None, 'rebalance_period': None}
)
m.pyfolio_full_tear_sheet()
m.risk_analyze()
            
# m=M.backtest.v5( 
#     instruments=instruments,
#     start_date=start_date, 
#     end_date=end_date,
#     # 必须传入initialize，只在第一天运行
#     initialize=initialize,
#     #  必须传入handle_data,每个交易日都会运行
#     handle_data=handle_data,
#     # 买入以开盘价成交
#     order_price_field_buy='open',
#     # 卖出也以开盘价成交
#     order_price_field_sell='close',
#     # 策略本金
#     capital_base=400000,
#     # 比较基准：沪深300
#     benchmark='000300.INDX',
#     m_cached=False,
#     volume_limit=0,
# )      


# # 4. 策略回测：https://bigquant.com/docs/module_trade.html
# m = M.trade.v1(
#     instruments=instruments,
#     start_date=start_date,
#     end_date=end_date,
#     initialize=initialize,
#     handle_data=handle_data,
#     # 买入订单以开盘价成交
#     order_price_field_buy='open',
#     # 卖出订单以开盘价成交
#     order_price_field_sell='open',
#     capital_base=capital_base,
#     benchmark=benchmark,
#     # 传入数据给回测模块，所有回测函数里用到的数据都要从这里传入，并通过 context.options 使用，否则可能会遇到缓存问题
#     options={'selected_data': selected_data, 'rebalance_period': rebalance_period}
# )